### **详细设计文档 - 剖析服务 (ProfilingService)**

#### **1. 模块概述**

**1.1. 核心职责**

`ProfilingService`是平台剖析业务的核心业务编排器。它不执行具体的数据库查询，而是负责调度和协调其他服务，以完成一次完整的端到端数据剖析任务。其核心职责包括：

  * **任务生命周期管理**: 接收剖析请求，创建`ProfilingTask`实体，并管理其从`PENDING`到`RUNNING`，最终到`SUCCESS`或`FAILED`的整个状态流转。
  * **异步执行**: 将耗时的数据剖析操作放入后台线程中异步执行，确保API调用能够快速响应，不阻塞客户端。
  * **统一任务调度**: 处理统一的剖析请求，无论是针对单个数据源还是多个数据源，都由它统一进行调度。
  * **服务协调**: 作为中心协调者，它依次调用`DataSourceService`、`IDatabaseProfiler`、`ReportAssemblyService`和`StructuredReportService`来完成数据获取、加工和存储的全过程。

**1.2. 核心实体与API**

  * **核心实体**: `com.dataprofiler.entity.ProfilingTask`
  * **服务接口**: `com.dataprofiler.service.ProfilingService`
  * **API入口**: `com.dataprofiler.controller.ProfilingTaskController`

#### **2. 接口定义 (Java Interface)**

```java
package com.dataprofiler.service;

import com.dataprofiler.dto.request.ProfilingTaskRequest;
import com.dataprofiler.dto.response.TaskStatusResponse;
import com.dataprofiler.entity.ProfilingTask;

import java.util.Optional;

public interface ProfilingService {

    /**
     * 接收剖析请求，创建任务并立即返回，然后异步执行该任务。
     * @param request 包含一个或多个数据源及其剖析范围的请求对象。
     * @return 刚创建的任务实体，包含了唯一的taskId和初始状态。
     */
    ProfilingTask startProfilingTask(ProfilingTaskRequest request);

    /**
     * 根据任务ID获取任务的当前状态。
     * @param taskId 任务的唯一ID。
     * @return 包含任务状态信息的Optional DTO。
     */
    Optional<TaskStatusResponse> getTaskStatus(String taskId);

}
```

#### **3. 核心流程与实现逻辑**

**3.1. 异步任务执行机制**

为保证API的快速响应，`startProfilingTask`方法本身不执行耗时操作。

  * **实现建议**:
    1.  公共方法`startProfilingTask`负责创建和保存一个初始状态为`PENDING`的`ProfilingTask`实体到数据库，并立即返回该实体。
    2.  在`ProfilingService`内部定义一个私有的、使用Spring的`@Async`注解标记的方法，例如 `executeTaskAsync(String taskId)`。
    3.  `startProfilingTask`在返回前，调用`executeTaskAsync(taskId)`来启动后台处理流程。这需要应用主类上启用`@EnableAsync`。

**3.2. 统一任务处理流程 (在`@Async`方法中执行)**

1.  **任务初始化**:

      * 根据传入的`taskId`，从数据库中加载`ProfilingTask`实体。
      * 将任务状态更新为`RUNNING`并保存。

2.  **请求解析与并行调度**:

      * 从`ProfilingTask`中获取原始的`ProfilingTaskRequest`载荷。
      * 解析出需要处理的数据源ID列表。
      * **如果请求包含多个数据源**，建议使用`CompletableFuture.allOf()`结合一个自定义的线程池，对每个数据源的剖析过程进行**并行处理**，以最大化效率。

3.  **循环处理每个数据源**:

      * 对于请求中的每一个`dataSourceId`：
        a. **获取配置**: 调用 `dataSourceService.getDataSourceById(dataSourceId)` 获取其`DataSourceConfig`。
        b. **获取剖析器**: 使用一个**剖析器工厂 (ProfilerFactory)** 或一个由Spring注入的`Map<String, IDatabaseProfiler>`，根据`DataSourceConfig`的`type`（如`MYSQL`）获取对应的`Profiler`实例。
        c. **执行剖析**: 调用 `profiler.profile(config, tablesToProfile)`。**此步骤是阻塞的（针对当前子任务）**。`Profiler`内部会完整地执行“自适应策略”——包括预检、决策和最终的SQL查询。
        d. **收集原始数据**: `profile()`方法成功执行后，返回一个`RawProfileDataDto`对象。
        e. **子任务错误处理**: 在`try-catch`块中执行上述步骤。如果某个数据源剖析失败，记录详细错误日志到`ProfilingTask`实体中，然后可以选择继续处理其他数据源。

4.  **数据聚合与组装**:

      * 所有数据源的子任务处理完毕后，`ProfilingService`会收集到一个`List<RawProfileDataDto>`（每个元素对应一个成功剖析的数据源）。
      * 将这个原始数据列表传递给 `reportAssemblyService.assemble(list_of_raw_data)`。

5.  **报告持久化**:

      * `ReportAssemblyService`返回最终的`StructuredReportDto`（该对象内部已包含了所有数据源的结果）。
      * `ProfilingService`调用 `structuredReportService.saveReport(taskId, final_report)` 将这份完整的报告持久化。

6.  **任务状态终结**:

      * 根据所有子任务的执行结果，更新`ProfilingTask`的最终状态。
          * 如果全部成功，则为`SUCCESS`。
          * 如果部分失败，可设为`PARTIAL_SUCCESS`。
          * 如果因关键错误导致整体失败，则为`FAILED`。
      * 更新任务的`completedAt`时间戳。

#### **4. 自适应策略的调度**

需要明确的是，`ProfilingService`本身并**不关心**自适应策略的内部细节。它的职责是“委托”。它只负责根据数据源类型，选择正确的`Profiler`（工人），然后将`DataSourceConfig`（工具和原料）交给它，并说“开始工作”。

至于`Profiler`是选择用“精密仪器”（精确查询）还是“普通工具”（近似查询），这个决策完全封装在`Profiler`内部，`ProfilingService`对此无感知。这完全体现了面向接口编程和单一职责原则。

#### **5. 数据结构定义**

  * **`ProfilingTask` (JPA Entity)**

      * 映射到SQLite的`profiling_tasks`表，是任务生命周期的状态机。
      * **核心字段**:
          * `id` (String, PK): 任务唯一ID。
          * `status` (Enum: `PENDING`, `RUNNING`, `SUCCESS`, `PARTIAL_SUCCESS`, `FAILED`): 任务状态。
          * `requestPayload` (String/TEXT): 原始`ProfilingTaskRequest`的JSON字符串，用于追溯和重试。
          * `createdAt`, `startedAt`, `completedAt` (LocalDateTime): 时间戳。
          * `errorLog` (String/TEXT): 记录任务失败的错误信息。

  * **`ProfilingTaskRequest` (DTO)**: API请求体，其结构已在API设计文档中定义。

  * **`TaskStatusResponse` (DTO)**: 获取任务状态API的响应体。

    ```java
    public class TaskStatusResponse {
        private String taskId;
        private String status; // PENDING, RUNNING, SUCCESS...
        private LocalDateTime createdAt;
        private LocalDateTime completedAt;
        private String errorLog;
    }
    ```

#### **6. API 端点**

由`ProfilingTaskController`暴露以下RESTful API：

| Method | Path | 调用服务方法 | 描述 |
| :--- | :--- | :--- | :--- |
| `POST` | `/profiling-tasks` | `startProfilingTask` | 发起一个新的（单源或多源）剖析任务 |
| `GET` | `/task-status/{taskId}`| `getTaskStatus` | 查询指定任务的当前状态 |