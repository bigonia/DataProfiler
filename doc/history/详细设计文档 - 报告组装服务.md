在`ProfilingService`完成了对原始数据的调度和获取之后，数据流转到了`ReportAssemblyService`。这个模块是平台的“数据精炼厂”，负责将原始、零散的数据点加工成富有洞察力的、结构化的信息。

-----

### **详细设计文档 - 报告组装服务 (ReportAssemblyService)**

#### **1. 模块概述**

**1.1. 核心职责**

`ReportAssemblyService`是平台数据处理流程中的核心转换与计算模块。其单一且明确的职责是：接收由`Profiler`层生成的、未经加工的`RawProfileDataDto`对象，并将其**丰富化、结构化**，最终转换成可供API消费和持久化的、标准化的`StructuredReportDto`对象。

可以将其理解为数据处理管道中的\*\*“转换层 (Transform Layer)”\*\*。它负责：

  * **计算派生指标**: 如比率、百分比等。
  * **执行高级统计**: 基于数据样本，在应用层内存中进行更复杂的统计计算（如平均值、标准差）。
  * **格式化与标准化**: 将所有原始及计算得出的指标，统一组装到最终的报告结构中。

**1.2. 核心交互**

  * **上游服务**: `ProfilingService`。在获取到`RawProfileDataDto`后，会调用本服务进行处理。
  * **下游服务**: `ProfilingService`。本服务在完成组装后，将`StructuredReportDto`返回给`ProfilingService`，由其继续后续的持久化流程。
  * **API入口**: 无。这是一个纯粹的内部业务服务，不直接对外部暴露API。

**1.3. 主要接口**

  * **服务接口**: `com.dataprofiler.service.ReportAssemblyService`

#### **2. 接口定义 (Java Interface)**

```java
package com.dataprofiler.service;

import com.dataprofiler.dto.internal.RawProfileDataDto;
import com.dataprofiler.dto.response.StructuredReportDto;

import java.util.List;

public interface ReportAssemblyService {

    /**
     * 将一个或多个原始剖析数据对象组装成标准化的报告对象。
     * @param rawDataList 从Profiler获取到的原始数据列表，每个元素对应一个数据源。
     * @param taskId 本次剖析任务的全局ID。
     * @return 组装完成的标准化报告列表，每个元素对应一个输入的数据源。
     */
    List<StructuredReportDto> assembleReport(List<RawProfileDataDto> rawDataList, String taskId);

}
```

#### **3. 核心流程与实现逻辑**

`assembleReport`方法是本服务的核心，其内部实现包含了一系列精细的数据处理步骤。

1.  **遍历数据源**: 方法首先会遍历输入的`rawDataList`，对每一个`RawProfileDataDto`（代表一个数据源的原始剖析结果）执行独立的组装逻辑，最终生成一个对应的`StructuredReportDto`。

2.  **映射基础信息**: 将`RawProfileDataDto`中的`dataSourceId`, `databaseProfile`等顶层信息，直接映射到新的`StructuredReportDto`对象中。

3.  **列级别指标的丰富化 (核心)**: 遍历每个表中的每一列，为其构建包含丰富指标的`metrics`对象。这是本服务最重要的工作。

      * **a. 直接映射**: 将`RawProfileDataDto`中已有的基础指标（如`min`, `max`）直接复制到`StructuredReportDto`的`metrics`对象中。
      * **b. 派生指标计算**:
          * **空值率 (`nullRate`)**: `(double) rawColumn.getNullCount() / table.getRowCount()`
          * **唯一率 (`distinctRate`)**: `(double) rawColumn.getDistinctCount() / table.getRowCount()`
          * *注意：需要处理`rowCount`为0的除零异常。*
      * **c. 基于样本的高级计算 (Sample-based Metrics)**:
          * 检查`RawProfileDataDto`的`isSampled`标志位和`sampleRows`字段。如果样本存在，则在**应用层内存**中对样本数据进行计算，这极大地减轻了源数据库的压力。
          * **数值类型指标**: 遍历样本中该列的所有数值，计算`平均值 (avg)`, `标准差 (stddev)`, `中位数 (median)`, `百分位数 (percentiles)`等。
          * **字符串类型指标**: 遍历样本中该列的所有字符串，计算`最小长度 (minLength)`, `最大长度 (maxLength)`, `平均长度 (avgLength)`。
          * **（可扩展）格式与模式分析**: 这是未来进行AI分析的重要基础。可以在此步骤中，通过正则表达式或自定义逻辑，分析样本数据以识别常见格式（如Email, URL, UUID）的比例。
      * **d. 组装`metrics`对象**: 将上述所有获取和计算出的指标，统一填充到一个为该列新创建的`metrics`对象中。

4.  **构建最终报告**: 将所有经过丰富化处理的表和列信息，组装成一个完整的`StructuredReportDto`对象。

#### **4. 数据结构定义 (输入与输出)**

本服务是数据形态发生“质变”的节点。

  * **输入**: `RawProfileDataDto`

      * **角色**: **原始物料**。
      * **特点**: 结构精简，只包含从数据库直接获取的元数据和基础聚合值（如`min`, `max`），不含任何比率或高级统计。
      * **示例节选**:
        ```json
        // Raw Column Profile
        {
          "columnName": "order_amount",
          "columnType": "NUMERIC(10, 2)",
          "range": { "min": 0.50, "max": 9999.99 }
          // ... 只包含最基础的信息
        }
        ```

  * **输出**: `StructuredReportDto`

      * **角色**: **精加工成品**。
      * **特点**: 信息丰富，包含了所有二次计算和派生出的指标，格式友好，可直接用于API响应和前端展示。
      * **示例节选 (与上文对应)**:
        ```json
        // Structured Column Report
        {
          "name": "order_amount",
          "type": "NUMERIC(10, 2)",
          "metrics": {
            "nullCount": 50,
            "nullRate": 0.000033,       // <-- 新增
            "distinctCount": 12800,
            "distinctRate": 0.00853,    // <-- 新增
            "range": {
              "min": 0.50,
              "max": 9999.99
            },
            "avg": 125.75,              // <-- 新增 (基于样本计算)
            "stddev": 89.5,             // <-- 新增 (基于样本计算)
            "minLength": 4,             // <-- 新增 (基于样本计算)
            "maxLength": 12,            // <-- 新增 (基于样本计算)
            "avgLength": 7.8            // <-- 新增 (基于样本计算)
          }
        }
        ```

#### **5. 扩展性考虑**

为了便于未来增加新的分析指标（例如，计算偏度、峰度或特定业务规则），`ReportAssemblyService`的内部实现可以采用**策略模式**。

  * **设计**:
      * 定义一个`MetricCalculator`接口，其中包含`calculate(ColumnSample data)`方法。
      * 为每个指标（如`AverageCalculator`, `NullRateCalculator`, `StringLengthCalculator`）创建一个实现该接口的类。
      * `ReportAssemblyService`持有一个`List<MetricCalculator>`。在处理每列数据时，它会遍历这个计算器列表，并将它们依次应用于该列的样本数据上，动态地构建出`metrics`对象。
  * **优点**:
      * **开闭原则**: 新增一个指标时，只需增加一个新的`MetricCalculator`实现类，无需修改`ReportAssemblyService`的核心逻辑。
      * **职责清晰**: 每个计算器的逻辑都高度内聚，易于开发和测试。
      * 这在精神上继承了早期设计中“可插拔分析点”的灵活性，但将其置于一个更受控、更高效的内部流程中。