### **详细设计文档 - 数据库剖析器 (IDatabaseProfiler)**

#### **1. 模块概述**

**1.1. 核心职责**

`IDatabaseProfiler`及其实现类是平台数据剖析的**核心执行单元**。如果说`ProfilingService`是大脑，那么`Profiler`就是深入到各个数据源进行实际操作的手和眼睛。

其核心职责是**封装所有与特定数据库方言相关的操作**，包括：

  * **数据库连接**: 建立和管理到目标数据源的JDBC连接。
  * **SQL方言适配**: 编写并执行针对特定数据库（如MySQL, SQL Server）的、最高效的SQL查询。
  * **执行自适应策略**: 内部实现“预检-决策-执行”的逻辑，根据表大小自动选择精确或近似的分析路径。
  * **数据映射**: 将从数据库查询返回的`ResultSet`，标准地映射为平台内部统一的`RawProfileDataDto`对象。

通过这种设计，我们将所有与数据库相关的复杂性和差异性都隔离在了`Profiler`模块内部，使得上层的`ProfilingService`可以保持简洁和通用。

**1.2. 核心交互**

  * **上游服务**: `ProfilingService`。根据数据源类型，调用对应的`Profiler`实例来执行剖析。
  * **交互对象**: 直接通过JDBC与外部的目标数据源进行交互。
  * **下游服务**: 无。它将`RawProfileDataDto`作为结果返回给`ProfilingService`。

**1.3. 主要接口与实现**

  * **服务接口**: `com.dataprofiler.profiler.IDatabaseProfiler`
  * **实现类**: `com.dataprofiler.profiler.impl.MySqlProfiler`, `com.dataprofiler.profiler.impl.SqlServerProfiler`, `com.dataprofiler.profiler.impl.SqliteProfiler` 等。

#### **2. 接口定义 (Java Interface)**

所有具体的`Profiler`都必须实现这个统一的接口。

```java
package com.dataprofiler.profiler;

import com.dataprofiler.dto.internal.RawProfileDataDto;
import com.dataprofiler.entity.DataSourceConfig;
import java.util.List;
import java.util.Map;

public interface IDatabaseProfiler {

    /**
     * 对指定数据源中的特定表执行剖析操作。
     * @param config 目标数据源的完整连接配置。
     * @param tablesToProfile 需要剖析的表范围，Key为Schema名，Value为该Schema下的表名列表。
     * @return 包含了所有原始剖析结果的数据传输对象。
     */
    RawProfileDataDto profile(DataSourceConfig config, Map<String, List<String>> tablesToProfile);

    /**
     * 声明本剖析器支持的数据库类型。
     * 用于ProfilerFactory进行实例选择。
     * @return 数据库类型字符串，如 "MYSQL", "SQLSERVER"。
     */
    String getSupportedType();
}
```

#### **3. 核心实现逻辑**

以一个典型的实现类 `MySqlProfiler` 为例，其内部逻辑如下：

**3.1. 剖析器工厂 (Profiler Factory)**

`ProfilingService`中会注入一个`List<IDatabaseProfiler>`。当需要执行任务时，它会通过一个工厂方法来获取正确的`Profiler`实例：

```java
// In ProfilingService
private IDatabaseProfiler getProfiler(String dataSourceType) {
    return allProfilers.stream()
            .filter(p -> p.getSupportedType().equalsIgnoreCase(dataSourceType))
            .findFirst()
            .orElseThrow(() -> new UnsupportedOperationException("Unsupported DB type: " + dataSourceType));
}
```

**3.2. `profile` 方法实现流程**

这是`Profiler`的核心方法，它完整地封装了自适应剖析策略。

1.  **建立连接**:

      * 根据传入的`DataSourceConfig`中的`properties`，构建JDBC URL、用户名和密码。
      * 使用`DriverManager.getConnection()`或数据源池获取一个JDBC连接。此连接应在`try-with-resources`块中管理，以确保最终被关闭。

2.  **遍历目标表**:

      * 循环遍历传入的`tablesToProfile`（一个包含了Schema和对应表列表的Map）。

3.  **对每个表执行自适应剖析**:

      * **a. 阶段一：元数据预检**
          * 执行在《数据库分析实现指南》中定义的**低成本SQL**，从`information_schema`中获取该表的**估算行数** (`rowCount`) 和所有列的元数据（列名、类型、注释、主键信息）。
      * **b. 决策**
          * 将获取的`rowCount`与系统内部的**阈值**（如10万）进行比较。
      * **c. 阶段二：指标获取**
          * **如果 `rowCount < 阈值` (精确路径)**:
              * 动态构建一个包含所有列的`SELECT COUNT(DISTINCT col), MIN(col), MAX(col)...`的**单次聚合SQL**。
              * 执行该SQL，获取一个包含了所有列精确指标的`ResultSet`。
          * **如果 `rowCount >= 阈值` (近似路径)**:
              * 执行在《数据库分析实现指南》中定义的**采样SQL**（如`SELECT ... WHERE RAND() < percentage LIMIT 1000`）。
              * 将采样结果（`sampleRows`）存入内存。
              * 在**应用层内存**中对样本数据进行遍历，计算出近似的`min`, `max`等指标。
              * **注意**: 对于大表，`distinctCount`等指标此时也应基于样本进行估算，或者使用数据库特定的近似聚合函数。

4.  **数据映射 (ResultSet to DTO)**:

      * 将上一步中获取到的所有元数据和指标，填充到`RawProfileDataDto`对应的`TableProfile`和`ColumnProfile`对象中。

5.  **返回结果**:

      * 在处理完所有请求的表之后，返回一个包含了所有结果的、完整的`RawProfileDataDto`对象。

#### **4. SQL指令集引用**

每个具体的`Profiler`实现类（`MySqlProfiler`, `SqlServerProfiler`, `SqliteProfiler`）所使用的确切SQL语句，必须严格遵循\*\*《数据库分析实现指南（SQL指令集）》\*\*文档。本文档定义了逻辑流程，而SQL指南提供了具体的实现弹药。

#### **5. 数据结构定义**

  * **输出 (Output)**: `RawProfileDataDto`
      * **角色**: 本模块的**唯一产出物**。它是一个标准化的、与具体数据库方言无关的“原始物料”对象。
      * **结构**: 其结构已在《模块交互与数据定义文档》中详细定义，核心是清晰地分离了**元数据 (metadata)** 和 **基础剖析指标 (profiledMetrics)**。